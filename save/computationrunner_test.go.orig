package body

import (
	"nbodygo/cmd/cmap"
	"testing"
	"time"
)

const testTimeScaling = float32(.000000001)
const maxQueues = 5
const bodyCount = 10

// define a test body an implement the SimBody interface on it: needed to exercise the computation runner
type TestBody struct {
	id int
	exists bool
	otherBodyCount int
}

func (body *TestBody) ForceComputer(bodyQueue *cmap.ConcurrentMap, result chan<- bool) {
	for item := range bodyQueue.IterBuffered() {
		if item.Val.(*TestBody) != body {
			body.otherBodyCount++
		}
	}
	result<- true
}

func (body *TestBody) Update(float32) BodyRenderInfo {
	return BodyRenderInfo{}
}

func (body *TestBody) Exists() bool {
	return body.exists
}

func (body *TestBody) Id() int {
	return body.id
}

// tests that the computation runner doesn't fail with no bodies
func TestRunnerNoBodies(t *testing.T) {
	rqh := NewResultQueueHolder(maxQueues)
	bodyQueue := cmap.New()
	newRunner(testTimeScaling, rqh, &bodyQueue)
	runner.runOneComputation()
	StopComputationRunner()
}

// using the TestBody, runs a basic test of the computation runner to see that it invokes the force
// calc on all bodies in the body queue
func TestRunnerBasic(t *testing.T) {
	rqh := NewResultQueueHolder(maxQueues)
	bodyQueue := cmap.New()
	for i := 0; i < bodyCount; i++ {
		bodyQueue.Set(i, &TestBody{i, true, 0})
	}
	newRunner(testTimeScaling, rqh, &bodyQueue)
	runner.runOneComputation()
	for i := 0; i < 10; i++ {
		item := bodyQueue.Items()[i]
		if item == nil {
			t.Error("Expected body not found")
		}
		if item.(*TestBody).otherBodyCount != bodyCount- 1 {
			t.Errorf("Computation runner did not compute all bodies. Expected: %v. Actual: %v", bodyCount- 1,
				item.(*TestBody).otherBodyCount)
			break
		}
	}
	StopComputationRunner()
}

// tests the runner as a goroutine. This test has no queue consumer so the runner should fill the
// result queue and then keep running, but without doing anything
func TestRunnerGoroutine(t *testing.T) {
	rqh := NewResultQueueHolder(maxQueues)
	bodyQueue := cmap.New()
	for i := 0; i < bodyCount; i++ {
		bodyQueue.Set(i, &TestBody{i, true, 0})
	}
	runner := StartComputationRunner(testTimeScaling, rqh, &bodyQueue)
	time.Sleep(time.Second)
	if runner.computations != maxQueues {
		t.Errorf("Runner should have maxed the result queue and stopped. Expected: %v. Actual: %v", maxQueues, runner.computations)
	}
	StopComputationRunner()
}

// tests the runner as a goroutine with a queue consumer. The consumer pulls computed queues, allowing the
// computation runner to perform more computations
func TestRunnerGoroutineConsumer(t *testing.T) {
	rqh := NewResultQueueHolder(maxQueues)
	// create a function to perpetually get computed queues generated by the computation runner
	go func() {
		for {
			rqh.nextComputedQueue()
			time.Sleep(time.Millisecond * 10)
		}
	}()
	bodyQueue := cmap.New()
	for i := 0; i < bodyCount; i++ {
		bodyQueue.Set(i, &TestBody{i, true, 0})
	}
	runner := StartComputationRunner(testTimeScaling, rqh, &bodyQueue)
	time.Sleep(time.Second)
	if runner.computations <= maxQueues {
		t.Errorf("Incorrect runner computations. Expected more than: %v. Actual: %v", maxQueues, runner.computations)
	}
	StopComputationRunner()
}
