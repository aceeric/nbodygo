package runner

import (
	"math/rand"
	"nbodygo/cmd/body"
	"nbodygo/cmd/bodyrender"
	"nbodygo/cmd/cmap"
	"nbodygo/cmd/globals"
	"nbodygo/cmd/interfaces"
	"nbodygo/cmd/util"
	"testing"
	"time"
)

const testTimeScaling = float32(.000000001)
const maxQueues = 5
const bodyCount = 1000

// define a test body an implement the SimBody interface on it: needed to exercise the computation runner
type TestBody struct {
	id int
	exists bool
	otherBodyCount int
}

func (tb *TestBody) ForceComputer(bodyQueue *cmap.ConcurrentMap) {
	for item := range bodyQueue.IterBuffered() {
		if item.Val.(*TestBody) != tb {
			tb.otherBodyCount++
		}
	}
}

func (tb *TestBody) Update(float32) interfaces.Renderable {
	return bodyrender.NewEmpty()
}

func (tb *TestBody) Exists() bool {
	return tb.exists
}

func (tb *TestBody) Id() int {
	return tb.id
}

func (tb *TestBody) SetSun(){
}

// https://splice.com/blog/golang-verify-type-implements-interface-compile-time/
var _ interfaces.SimBody = (*TestBody)(nil)

// tests that the computation runner doesn't fail with no bodies
func TestRunnerNoBodies(t *testing.T) {
	rqh := NewResultQueueHolder(maxQueues)
	bodyQueue := cmap.New()
	newRunner(4, testTimeScaling, rqh, &bodyQueue)
	runner.runOneComputation()
	StopComputationRunner()
}

func TestThisWorks(t *testing.T) {
	t.Skip()
	type Z struct {
		i interface{}
	}
	z := Z{
		i: &TestBody{}, // always assign interface with ampersand !?!?!??!
	}
	t.Logf("%+v\n", z)
	e := z.i.(*TestBody) // and deref through pointer !?!?!??!
	var iface interface{}
	iface = &TestBody{}
	zxc := iface.(*TestBody)
	t.Logf("%v\n", zxc)
	qwe := iface.(interfaces.SimBody) // but when deref interface - don't use pointer !?!?!??!
	t.Logf("%v\n", qwe)
	qwe2 := iface.(interfaces.SimBody)
	t.Logf("%v\n", qwe2)
	qwe2.Exists()
	t.Logf("%v\n", e)
	t.Logf("%v\n", e.Exists())
	b := z.i.(interfaces.SimBody)
	t.Logf("%+v\n", b)
}

// succeeded Thu Apr 16 19:19:32 EDT 2020
func TestBodyQueue(t *testing.T) {
	bodyQueue := cmap.New()
	for i := 0; i < 1; i++ {
		bodyQueue.Set(i, &TestBody{i, true, 0}) // ampersand
	}
	for item := range bodyQueue.IterBuffered() {
		b := item.Val.(interfaces.SimBody) // no pointer
		_ = b
		//t.Logf("%+v\n", b)
	}
}

// using the TestBody, runs a basic test of the computation runner to see that it invokes the force
// calc on all bodies in the body queue
func TestRunnerBasic(t *testing.T) {
	rqh := NewResultQueueHolder(maxQueues)
	bodyQueue := cmap.New()
	for i := 0; i < bodyCount; i++ {
		bodyQueue.Set(i, &TestBody{i, true, 0})
	}
	newRunner(4, testTimeScaling, rqh, &bodyQueue)
	runner.runOneComputation()
	for i := 0; i < 10; i++ {
		item := bodyQueue.Items()[i]
		if item == nil {
			t.Error("Expected body not found")
		}
		if item.(*TestBody).otherBodyCount != bodyCount- 1 {
			t.Errorf("Computation runner did not compute all bodies. Expected: %v. Actual: %v", bodyCount- 1,
				item.(*TestBody).otherBodyCount)
			break
		}
	}
	StopComputationRunner()
}

// tests the runner as a goroutine. This test has no queue consumer so the runner should fill the
// result queue and then keep running, but without doing anything
func TestRunnerGoroutine(t *testing.T) {
	rqh := NewResultQueueHolder(maxQueues)
	bodyQueue := cmap.New()
	for i := 0; i < bodyCount; i++ {
		bodyQueue.Set(i, &TestBody{i, true, 0})
	}
	runner := StartComputationRunner(4, &bodyQueue, testTimeScaling, rqh)
	time.Sleep(time.Second * 2)
	if runner.computations != maxQueues {
		t.Errorf("Runner should have maxed the result queue and stopped. Expected: %v. Actual: %v", maxQueues, runner.computations)
	}
	StopComputationRunner()
}

// tests the runner as a goroutine with a queue consumer. The consumer pulls computed queues, allowing the
// computation runner to perform more computations
func TestRunnerGoroutineConsumer(t *testing.T) {
	rqh := NewResultQueueHolder(maxQueues)
	// create a function to perpetually get computed queues generated by the computation runner
	go func() {
		for {
			rqh.NextComputedQueue()
			time.Sleep(time.Millisecond * 10)
		}
	}()
	bodyQueue := cmap.New()
	for i := 0; i < bodyCount; i++ {
		bodyQueue.Set(i, &TestBody{i, true, 0})
	}
	runner := StartComputationRunner(4, &bodyQueue, testTimeScaling, rqh)
	time.Sleep(time.Second * 2)
	if runner.computations <= maxQueues {
		t.Errorf("Incorrect runner computations. Expected more than: %v. Actual: %v", maxQueues, runner.computations)
	}
	StopComputationRunner()
}

func TestDeleteMe(t *testing.T) {
	const bodyCount = 2000
	const defaultMass = 1E10
	const defaultRadius = 10

	bodyQueue := cmap.New()
	for i := 0; i < bodyCount; i++ {
		p := util.RandomVector(100)
		v := util.RandomVector(100000000)
		mass := defaultMass * 1 + float32(rand.Int31n(3))
		radius := defaultRadius * 1 + float32(rand.Int31n(3))
		b := body.NewBody(i, p.X, p.Y, p.Z, v.X, v.Y, v.Z, mass, radius, globals.Elastic, globals.Red,
			0, 0, true, "b1", "b1",false)
		bodyQueue.Set(i, &b) // turn b into a pointer
	}
	start := time.Now()
	iterations := int64(0)
	for i := 0; i < 10000; i++ {
		for item := range bodyQueue.IterBuffered() {
			b := item.Val.(interfaces.SimBody) // no pointer
			_ = b
		}
		iterations++
	}
	stop := time.Now()
	millis := stop.Sub(start).Milliseconds()
	millisPerIteration := float32(millis) / float32(iterations)
	_ = stop; _ = millis; _ = millisPerIteration
	t.Logf("iterations: %v, millis: %v, ms/iteration: %v\n", iterations, millis, millisPerIteration)
}

func TestBodyForceComputerFromRunner(t *testing.T) {
	const testTimeScaling = float32(.000000001)
	const maxQueues = 5
	const bodyCount = 2000
	const defaultMass = 1E10
	const defaultRadius = 10

	testBody := body.NewBody(0, 0, 0, 0, 0, 0, 0, 0, 0, globals.Elastic,
		globals.Red, 0, 0, true, "b1", "b1",false)

	bodyQueue := cmap.New()
	for i := 0; i < bodyCount; i++ {
		b := testBody.CopyOfWithOverrides(body.BodyOverrides{ // TODO JUST USE NewBody
			Id:       i,
			Position: util.RandomVector(100),
			Velocity: util.RandomVector(100000000),
			Mass:     defaultMass * 1 + float32(rand.Int31n(3)),
			Radius:   defaultRadius * 1 + float32(rand.Int31n(3)),
		})
		bodyQueue.Set(i, b) // b is already a pointer
	}
	// create a function to perpetually get computed queues generated by the computation runner
	// with no lag - keep the queue as empty as possible
	rqh := NewResultQueueHolder(maxQueues)
	go func() {
		for {
			rqh.NextComputedQueue()
			time.Sleep(time.Millisecond * 1)
		}
	}()
	start := time.Now()
	StartComputationRunner(5, &bodyQueue, testTimeScaling, rqh)
	time.Sleep(time.Second * 15)
	stop := time.Now()
	stats := StopComputationRunner()
	millis := stop.Sub(start).Milliseconds()
	millisPerComputation := millis / int64(stats.Computations)
	_ = stop; _ = stats; _ = millis; _ = millisPerComputation
	t.Logf("iterations: %v, computations: %v, ms/compute: %v\n", stats.Iterations, stats.Computations,
		millis / int64(stats.Computations))
}

func TestRunnerConcurrent(t *testing.T) {
	// TODO computation runner while objects being added and removed
}